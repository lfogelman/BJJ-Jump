<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jumping Belts!</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* Basic styling for the page */
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #000000; /* Background is now black */
            font-family: 'Press Start 2P', cursive;
            color: white;
            text-align: center;
            flex-direction: column;
        }

        /* Styling for the game canvas */
        canvas {
            background-color: #87CEEB; /* Lighter sky blue for the canvas */
            border: 5px solid #2c3e50;
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2), 0 6px 6px rgba(0,0,0,0.25);
            display: block;
            max-width: 90%;
            max-height: 85vh; /* Use vh to ensure it fits vertically */
            aspect-ratio: 1 / 1; 
        }

        /* Styling for the game title and instructions */
        h1 {
            font-size: 2.5rem;
            text-shadow: 3px 3px 0px #2c3e50;
            margin-bottom: 1rem;
        }

        p {
            font-size: 1rem;
            margin-top: 1rem;
        }

        /* Styling for the new promotion info */
        .promotion-info {
            font-size: 0.75rem;
            margin-top: 1.5rem;
            opacity: 0.8;
            text-align: center;
        }
        .promotion-info p {
            margin-top: 0;
            margin-bottom: 0.5rem;
        }
        .belt-legend {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap; /* Allow wrapping on small screens */
        }
        .belt-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .belt-swatch {
            width: 20px;
            height: 12px;
            border: 1px solid #333;
        }
    </style>
</head>
<body>

    <h1>Jumping Belts!</h1> <!-- Title changed -->
    <canvas id="gameCanvas"></canvas>
    <p>Click, Tap, or press Spacebar to Jump!</p>
    
    <!-- Added belt promotion instructions with visual swatches -->
    <div class="promotion-info">
        <p><strong>PROMOTION SCORES</strong></p>
        <div class="belt-legend">
            <div class="belt-item">
                <span class="belt-swatch" style="background-color: #0077c8;"></span><span>2</span>
            </div>
            <span>|</span>
            <div class="belt-item">
                <span class="belt-swatch" style="background-color: #6a0dad;"></span><span>6</span>
            </div>
            <span>|</span>
            <div class="belt-item">
                <span class="belt-swatch" style="background-color: #964B00;"></span><span>14</span>
            </div>
            <span>|</span>
            <div class="belt-item">
                <span class="belt-swatch" style="background-color: #000000;"></span><span>30</span>
            </div>
            <span>|</span>
            <div class="belt-item">
                <span class="belt-swatch" style="background-color: #cc0000;"></span><span>62</span>
            </div>
        </div>
    </div>


    <script>
        // --- Canvas and Context Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // --- Game Configuration ---
        let bird, pipes, score, gameOver, gravity, jump, pipeSpeed, pipeGap, pipeWidth, pipeInterval, lastPipeHeight, birdBeltIndex, promotionThresholds;
        
        let backgroundLayers = [];
        let particles = [];
        
        let lastTime;
        let pipeTimer = 0;
        let animationFrameId;
        let gameStarted = false;

        // --- Asset Colors ---
        const PIPE_BELTS = [
            { fill: '#FFFFFF', border: '#CCCCCC' }, // White
            { fill: '#0077c8', border: '#005fa0' }, // Blue
            { fill: '#6a0dad', border: '#520a86' }, // Purple
            { fill: '#964B00', border: '#6d3700' }, // Brown
            { fill: '#000000', border: '#222222' }, // Black
            { fill: '#FF0000', border: '#cc0000' }  // Red
        ];
        
        const PLAYER_BELTS = ['#FFFFFF', '#0077c8', '#6a0dad', '#964B00', '#000000', '#cc0000'];
        // MODIFIED: Added belt names for the game over screen
        const PLAYER_BELT_NAMES = ['White', 'Blue', 'Purple', 'Brown', 'Black', 'Red'];

        // --- Game Logic ---

        // Function to draw a Colombian flag
        function drawFlag(x, y) {
            const flagWidth = 20;
            const flagHeight = 12;
            const poleHeight = 20;
            const poleWidth = 2;

            ctx.fillStyle = '#7f8c8d';
            ctx.fillRect(x, y - poleHeight, poleWidth, poleHeight);
            ctx.fillStyle = '#f1c40f';
            ctx.fillRect(x + poleWidth, y - poleHeight, flagWidth, flagHeight * 0.5);
            ctx.fillStyle = '#3498db';
            ctx.fillRect(x + poleWidth, y - poleHeight + flagHeight * 0.5, flagWidth, flagHeight * 0.25);
            ctx.fillStyle = '#e74c3c';
            ctx.fillRect(x + poleWidth, y - poleHeight + flagHeight * 0.75, flagWidth, flagHeight * 0.25);
        }

        // Function to create the Bogot√°-style background
        function createBackground() {
            backgroundLayers = [];
            const groundY = canvas.height;
            const mountains = {
                x: 0, speed: pipeSpeed * 0.1, hasFlag: true, flagPeak: Math.random() < 0.5 ? 1 : 2,
                draw: (offsetX) => {
                    ctx.fillStyle = '#2a4d3e';
                    ctx.beginPath();
                    const peak1X = offsetX + canvas.width * 0.3, peak1Y = groundY * 0.4;
                    const peak2X = offsetX + canvas.width * 0.7, peak2Y = groundY * 0.55;
                    ctx.moveTo(offsetX, groundY);
                    ctx.lineTo(offsetX, groundY * 0.6);
                    ctx.lineTo(peak1X, peak1Y);
                    ctx.lineTo(peak2X, peak2Y);
                    ctx.lineTo(offsetX + canvas.width, groundY * 0.45);
                    ctx.lineTo(offsetX + canvas.width, groundY);
                    ctx.closePath();
                    ctx.fill();
                    if (mountains.hasFlag) {
                        drawFlag((mountains.flagPeak === 1 ? peak1X : peak2X) - 10, mountains.flagPeak === 1 ? peak1Y : peak2Y);
                    }
                }
            };
            const midBuildings = {
                x: 0, speed: pipeSpeed * 0.3,
                draw: (offsetX) => {
                    ctx.fillStyle = '#556270';
                    ctx.fillRect(offsetX + canvas.width * 0.2, groundY * 0.4, 40, groundY * 0.6);
                    ctx.fillStyle = '#414a54';
                    ctx.fillRect(offsetX + canvas.width * 0.7, groundY * 0.5, 50, groundY * 0.5);
                }
            };
            const foreBuildings = {
                x: 0, speed: pipeSpeed * 0.6,
                draw: (offsetX) => {
                    ctx.fillStyle = '#8c9ba8';
                    ctx.fillRect(offsetX + canvas.width * 0.1, groundY * 0.6, 80, groundY * 0.4);
                    ctx.fillRect(offsetX + canvas.width * 0.4, groundY * 0.7, 60, groundY * 0.3);
                    ctx.fillRect(offsetX + canvas.width * 0.8, groundY * 0.65, 70, groundY * 0.35);
                }
            };
            backgroundLayers.push(mountains, midBuildings, foreBuildings);
        }

        // --- Game Initialization ---
        function setup() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }

            const aspectRatio = 1;
            const isMobile = window.innerWidth < 768;
            let canvasSize = isMobile ? window.innerWidth * 0.9 : window.innerHeight * 0.8;
            
            canvas.width = canvasSize;
            canvas.height = canvasSize;

            bird = { x: canvas.width / 4, y: canvas.height / 3, radius: canvas.height / 40, velocity: 0 };
            pipes = [];
            particles = [];
            score = 0;
            gameOver = false;
            gameStarted = false;
            
            gravity = canvas.height * 3.5;
            jump = -canvas.height * 0.85;
            
            pipeSpeed = canvas.width / 2.5;
            pipeInterval = 1.0;

            pipeWidth = canvas.width / 12; 
            pipeGap = canvas.height / 5;
            pipeTimer = pipeInterval;

            lastPipeHeight = canvas.height / 2;
            birdBeltIndex = 0;
            promotionThresholds = [2, 6, 14, 30, 62];
            
            lastTime = null;
            
            createBackground();
            
            setTimeout(() => {
                gameStarted = true;
            }, 1000);

            gameLoop();
        }

        // --- Drawing Functions ---
        function drawBackground() {
            ctx.globalAlpha = 0.4;
            backgroundLayers.forEach(layer => {
                layer.draw(layer.x);
                layer.draw(layer.x + canvas.width);
            });
            ctx.globalAlpha = 1.0;
        }

        function drawBird() {
            const birdSize = bird.radius * 2;
            const birdX = bird.x - bird.radius;
            const birdY = bird.y - bird.radius;
            ctx.fillStyle = '#CCCCCC';
            ctx.strokeStyle = '#AAAAAA';
            ctx.lineWidth = 2;
            ctx.fillRect(birdX, birdY, birdSize, birdSize);
            ctx.strokeRect(birdX, birdY, birdSize, birdSize);
            const beltHeight = birdSize / 4;
            ctx.fillStyle = PLAYER_BELTS[birdBeltIndex];
            ctx.fillRect(birdX, bird.y - beltHeight / 2, birdSize, beltHeight);
        }
        
        function drawParticles() {
            for (let i = 0; i < particles.length; i++) {
                const p = particles[i];
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, p.size, p.size);
            }
        }

        function drawReadyScreen() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            ctx.font = `${canvas.height / 10}px 'Press Start 2P'`;
            ctx.textAlign = 'center';
            ctx.fillText('Oss!', canvas.width / 2, canvas.height / 2);
        }

        function drawPipes() {
            pipes.forEach(pipe => {
                ctx.fillStyle = pipe.color.fill;
                ctx.strokeStyle = pipe.color.border;
                ctx.lineWidth = 5;
                const bottomPipeY = pipe.topHeight + pipeGap;
                const bottomPipeHeight = canvas.height - bottomPipeY;
                ctx.fillRect(pipe.x, 0, pipe.width, pipe.topHeight);
                ctx.strokeRect(pipe.x, 0, pipe.width, pipe.topHeight);
                ctx.fillRect(pipe.x, bottomPipeY, pipe.width, bottomPipeHeight);
                ctx.strokeRect(pipe.x, bottomPipeY, pipe.width, bottomPipeHeight);
                const barHeight = pipe.width / 5;
                let barColor = '#000000';
                if (pipe.color.fill === '#000000') barColor = '#cc0000';
                else if (pipe.color.fill === '#FF0000') barColor = '#FFFFFF';
                ctx.fillStyle = barColor;
                ctx.fillRect(pipe.x, pipe.topHeight - barHeight, pipe.width, barHeight);
                ctx.fillRect(pipe.x, bottomPipeY, pipe.width, barHeight);
            });
        }

        function drawScore() {
            ctx.fillStyle = 'white';
            ctx.font = `${canvas.height / 15}px 'Press Start 2P'`;
            ctx.textAlign = 'center';
            ctx.fillText(score, canvas.width / 2, canvas.height / 8);
        }

        // MODIFIED: drawGameOver now shows the achieved belt
        function drawGameOver() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            ctx.font = `${canvas.height / 12}px 'Press Start 2P'`;
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - canvas.height / 10);
            
            ctx.font = `${canvas.height / 25}px 'Press Start 2P'`;
            ctx.fillText(`Score: ${score}`, canvas.width / 2, canvas.height / 2 - canvas.height/40);

            // Display achieved belt
            const beltName = PLAYER_BELT_NAMES[birdBeltIndex];
            const beltText = `You got to ${beltName} Belt`;
            ctx.font = `${canvas.height / 35}px 'Press Start 2P'`;
            ctx.fillText(beltText, canvas.width / 2, canvas.height / 2 + canvas.height / 25);
            
            // Draw the belt swatch
            const beltSwatchWidth = 80;
            const beltSwatchHeight = 20;
            const beltSwatchX = canvas.width / 2 - beltSwatchWidth / 2;
            const beltSwatchY = canvas.height / 2 + canvas.height / 15;
            
            ctx.fillStyle = PLAYER_BELTS[birdBeltIndex];
            ctx.fillRect(beltSwatchX, beltSwatchY, beltSwatchWidth, beltSwatchHeight);
            
            // Draw rank bar on swatch
            const barHeight = beltSwatchHeight;
            const barWidth = beltSwatchWidth / 5;
            let barColor = '#000000';
            if (PLAYER_BELTS[birdBeltIndex] === '#000000') barColor = '#cc0000';
            if (PLAYER_BELTS[birdBeltIndex] === '#cc0000') barColor = '#FFFFFF';
            ctx.fillStyle = barColor;
            ctx.fillRect(beltSwatchX + beltSwatchWidth - barWidth, beltSwatchY, barWidth, barHeight);

            ctx.fillStyle = 'white';
            ctx.font = `${canvas.height / 35}px 'Press Start 2P'`;
            ctx.fillText('Click to Restart', canvas.width / 2, canvas.height / 2 + canvas.height / 6);
        }
        
        function createExplosion(x, y, colors) {
            const particleCount = 40;
            for (let i = 0; i < particleCount; i++) {
                particles.push({
                    x: x, y: y, size: Math.random() * 4 + 1,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    velocityX: (Math.random() - 0.5) * 400,
                    velocityY: (Math.random() - 0.5) * 400,
                    life: 0.8
                });
            }
        }

        function update(deltaTime) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.velocityX * deltaTime;
                p.y += p.velocityY * deltaTime;
                p.velocityY += gravity * 0.5 * deltaTime;
                p.life -= deltaTime;
                if (p.life <= 0) particles.splice(i, 1);
            }

            if (!gameStarted || gameOver) return;

            backgroundLayers.forEach(layer => {
                layer.x -= layer.speed * deltaTime;
                if (layer.x < -canvas.width) layer.x = 0;
            });

            bird.velocity += gravity * deltaTime;
            bird.y += bird.velocity * deltaTime;

            pipeTimer += deltaTime;
            if (pipeTimer > pipeInterval) {
                generatePipes();
                pipeTimer = 0;
            }
            pipes.forEach(pipe => { pipe.x -= pipeSpeed * deltaTime; });
            pipes = pipes.filter(pipe => pipe.x + pipe.width > 0);
            
            checkCollisions();

            pipes.forEach(pipe => {
                if (!pipe.passed && bird.x > pipe.x + pipe.width) {
                    pipe.passed = true;
                    score++;
                    if (birdBeltIndex < promotionThresholds.length && score >= promotionThresholds[birdBeltIndex]) {
                        birdBeltIndex++;
                        createExplosion(bird.x, bird.y, [PLAYER_BELTS[birdBeltIndex]]);
                    }
                }
            });
        }
        
        function generatePipes() {
            const maxDelta = canvas.height / 4.4; 
            const absMin = canvas.height / 8, absMax = canvas.height - pipeGap - absMin;
            let newMin = lastPipeHeight - maxDelta, newMax = lastPipeHeight + maxDelta;
            if (newMin < absMin) newMin = absMin;
            if (newMax > absMax) newMax = absMax;
            const topHeight = Math.random() * (newMax - newMin) + newMin;
            const randomColor = PIPE_BELTS[Math.floor(Math.random() * PIPE_BELTS.length)];
            pipes.push({ x: canvas.width, topHeight, width: pipeWidth, passed: false, color: randomColor });
            lastPipeHeight = topHeight;
        }

        function checkCollisions() {
            if (bird.y + bird.radius > canvas.height || bird.y - bird.radius < 0) {
                endGame();
                return;
            }
            pipes.forEach(pipe => {
                if (bird.x + bird.radius > pipe.x && bird.x - bird.radius < pipe.x + pipe.width &&
                    (bird.y - bird.radius < pipe.topHeight || bird.y + bird.radius > pipe.topHeight + pipeGap)) {
                    endGame();
                }
            });
        }

        function endGame() {
            if (gameOver) return;
            gameOver = true;
            createExplosion(bird.x, bird.y, [PLAYER_BELTS[birdBeltIndex], '#CCCCCC']);
        }

        function gameLoop(currentTime) {
            if (!lastTime) { lastTime = currentTime; }
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            update(deltaTime || 0);

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBackground();
            drawPipes();
            
            if (!gameOver) {
                drawBird();
            }

            drawParticles();
            drawScore();
            
            if (!gameStarted && !gameOver) {
                drawReadyScreen();
            }
            
            if (gameOver) {
                drawGameOver();
            }
            
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function handleJump() {
            if (gameOver) {
                setup();
            } else if (gameStarted) {
                bird.velocity = jump;
            }
        }

        window.addEventListener('resize', setup);
        document.addEventListener('keydown', (e) => { if (e.code === 'Space') handleJump(); });
        canvas.addEventListener('mousedown', handleJump);
        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleJump(); });

        setup();
    </script>

</body>
</html>
